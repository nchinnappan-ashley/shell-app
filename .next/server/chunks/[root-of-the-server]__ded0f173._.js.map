{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/NChinnappan/SourceAI/UI/shell-app/src/app/api/kb/query/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'fs';\nimport path from 'path';\n\n// Legacy chunk-level index (if present)\ntype Chunk = { id: number; file: string; idx: number; text: string };\ninterface KBIndexLegacy {\n  inverted: Record<string, number[]>;\n  tokenCounts: Array<[number, Array<[string, number]>]>;\n}\n\n// New doc-level index (memory-light)\ninterface KBFilesEntry { id: number; file: string; size: number }\ninterface KBDocIndex { [token: string]: number[] }\n\ntype Mode = 'chunk' | 'doc';\n\nlet loaded = false;\nlet mode: Mode = 'chunk';\n\n// chunk mode\nlet chunks: Chunk[] = [];\nlet inverted: Record<string, number[]> = {};\nlet tokenCounts: Map<number, Map<string, number>> = new Map();\n\n// doc mode\nlet files: KBFilesEntry[] = [];\nlet docInverted: KBDocIndex = {};\n\nfunction dataPath(...p: string[]) {\n  const base = process.cwd();\n  return path.join(base, 'shell-app', 'src', 'data', ...p);\n}\n\nfunction loadIndex() {\n  if (loaded) return;\n  const legacyIndex = dataPath('kb-index.json');\n  const legacyChunks = dataPath('kb-chunks.json');\n  const docIndex = dataPath('kb-doc-index.json');\n  const filesPath = dataPath('kb-files.json');\n\n  if (fs.existsSync(docIndex) && fs.existsSync(filesPath)) {\n    // Prefer doc-level index when available\n    docInverted = JSON.parse(fs.readFileSync(docIndex, 'utf8')) as KBDocIndex;\n    files = JSON.parse(fs.readFileSync(filesPath, 'utf8')) as KBFilesEntry[];\n    mode = 'doc';\n    loaded = true;\n    return;\n  }\n\n  if (fs.existsSync(legacyIndex) && fs.existsSync(legacyChunks)) {\n    const index: KBIndexLegacy = JSON.parse(fs.readFileSync(legacyIndex, 'utf8'));\n    const ch: Chunk[] = JSON.parse(fs.readFileSync(legacyChunks, 'utf8'));\n    chunks = ch;\n    inverted = index.inverted || {};\n    tokenCounts = new Map(index.tokenCounts.map(([id, pairs]) => [id, new Map(pairs)]));\n    mode = 'chunk';\n    loaded = true;\n    return;\n  }\n\n  throw new Error('KB index not found. Run: node shell-app/scripts/ingest-kb.js \"<source-folder>\" or ingest-kb-stream.js');\n}\n\nfunction tokenize(q: string) {\n  return q.toLowerCase().replace(/[^a-z0-9\\s]/g, ' ').split(/\\s+/).filter(Boolean);\n}\n\nfunction makeSnippet(text: string, centerIdx: number, matchLen = 0, radius = 160) {\n  const start = Math.max(0, centerIdx - radius);\n  const end = Math.min(text.length, centerIdx + matchLen + radius);\n  return text.slice(start, end).replace(/\\s+/g, ' ').trim();\n}\n\n// ---- chunk-mode search ----\nfunction keywordSearchChunk(query: string, k = 8) {\n  const tokens = tokenize(query);\n  const candSet = new Set<number>();\n  for (const t of tokens) (inverted[t] || []).forEach((id) => candSet.add(id));\n  const candidates = [...candSet];\n  const scored = candidates.map((id) => {\n    const counts = tokenCounts.get(id);\n    let score = 0;\n    if (counts) for (const t of tokens) score += counts.get(t) || 0;\n    return { id, score };\n  });\n  scored.sort((a, b) => b.score - a.score);\n  return scored.slice(0, k).map((s) => {\n    const ch = chunks.find((c) => c.id === s.id)!;\n    const lower = ch.text.toLowerCase();\n    const first = tokens.find((t) => lower.includes(t)) || '';\n    const idx = first ? lower.indexOf(first) : 0;\n    return { id: ch.id, file: ch.file, idx: ch.idx, score: s.score, snippet: makeSnippet(ch.text, idx, first.length) };\n  });\n}\n\nfunction regexSearchChunk(pattern: string, k = 8) {\n  const q = pattern.startsWith('/') && pattern.endsWith('/') ? pattern.slice(1, -1) : pattern;\n  const re = new RegExp(q, 'i');\n  const hits: Array<{ id: number; score: number } & any> = [];\n  for (const ch of chunks) {\n    const m = ch.text.match(re);\n    if (m) hits.push({ id: ch.id, file: ch.file, idx: ch.idx, score: m[0]?.length || 1, snippet: makeSnippet(ch.text, m.index || 0, m[0]?.length || 0) });\n  }\n  hits.sort((a, b) => b.score - a.score);\n  return hits.slice(0, k);\n}\n\n// ---- doc-mode streaming search ----\nfunction escapeRegExp(s: string) { return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); }\n\nasync function streamSearchFiles(fileIds: number[], re: RegExp, k = 8) {\n  const results: Array<{ file: string; idx: number; score: number; snippet: string }> = [];\n  for (const fid of fileIds) {\n    const f = files.find((x) => x.id === fid);\n    if (!f) continue;\n    const abs = dataPath('..', '..', f.file); // file path stored is relative to source; we saved relative\n    const absPath = path.isAbsolute(abs) ? abs : path.resolve(process.cwd(), 'shell-app', 'src', 'data', abs);\n    if (!fs.existsSync(f.file) && !fs.existsSync(abs) && !fs.existsSync(absPath)) continue;\n\n    const readPath = fs.existsSync(f.file) ? f.file : (fs.existsSync(abs) ? abs : absPath);\n    const stream = fs.createReadStream(readPath, { encoding: 'utf8', highWaterMark: 64 * 1024 });\n    let buffer = '';\n    let chunkIdx = 0;\n    const radius = 160;\n    const maxPerFile = 2;\n    let fileHits = 0;\n\n    for await (const chunk of stream) {\n      buffer += chunk;\n      // Keep buffer from growing unbounded\n      if (buffer.length > 4 * radius) buffer = buffer.slice(-4 * radius);\n      const m = re.exec(buffer);\n      if (m) {\n        const start = Math.max(0, (m.index || 0));\n        const snippet = buffer.slice(Math.max(0, start - radius), Math.min(buffer.length, start + m[0].length + radius)).replace(/\\s+/g, ' ').trim();\n        results.push({ file: f.file, idx: chunkIdx, score: m[0].length, snippet });\n        fileHits++;\n        if (results.length >= k || fileHits >= maxPerFile) break;\n      }\n      chunkIdx++;\n    }\n    if (results.length >= k) break;\n  }\n  return results;\n}\n\nfunction filesForTokens(tokens: string[]): number[] {\n  const set = new Set<number>();\n  for (const t of tokens) (docInverted[t] || []).forEach((id) => set.add(id));\n  return [...set];\n}\n\nasync function keywordSearchDoc(query: string, k = 8) {\n  const tokens = tokenize(query).filter((t) => t.length >= 3);\n  const candidates = tokens.length ? filesForTokens(tokens) : files.map((f) => f.id);\n  if (candidates.length === 0) return [];\n  const re = new RegExp(tokens.map(escapeRegExp).join('|'), 'i');\n  const hits = await streamSearchFiles(candidates, re, k);\n  // score by number of matched tokens in snippet\n  return hits.map((h) => ({ id: -1, file: h.file, idx: h.idx, score: h.score, snippet: h.snippet }));\n}\n\nasync function regexSearchDoc(pattern: string, k = 8) {\n  const q = pattern.startsWith('/') && pattern.endsWith('/') ? pattern.slice(1, -1) : pattern;\n  const re = new RegExp(q, 'i');\n  const allIds = files.map((f) => f.id);\n  const hits = await streamSearchFiles(allIds, re, k);\n  return hits.map((h) => ({ id: -1, file: h.file, idx: h.idx, score: h.score, snippet: h.snippet }));\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    loadIndex();\n    const { query, k = 8, regex = false } = await req.json();\n    if (!query || typeof query !== 'string') {\n      return NextResponse.json({ error: 'query (string) is required' }, { status: 400 });\n    }\n\n    if (mode === 'chunk') {\n      const results = regex || (query.startsWith('/') && query.endsWith('/')) ? regexSearchChunk(query, k) : keywordSearchChunk(query, k);\n      return NextResponse.json({ mode, results });\n    } else {\n      const results = regex || (query.startsWith('/') && query.endsWith('/')) ? await regexSearchDoc(query, k) : await keywordSearchDoc(query, k);\n      return NextResponse.json({ mode, results });\n    }\n  } catch (e: any) {\n    return NextResponse.json({ error: e.message || String(e) }, { status: 500 });\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}}]
}